Техническое задание: Реализация полнотекстового поиска в справочнике
1. Цель задачи
Реализовать систему полнотекстового поиска для справочника из 3000+ позиций, которая позволяет находить элементы по всем словам из поискового запроса, а не только по одному ключевому слову.

2. Проблема текущей реализации
Текущий поиск работает только по одному ключевому слову из всего запроса. Например:

Запрос "Демонтаж" → находит все позиции с этим словом

Запрос "Демонтаж стяжки" → не находит "Демонтаж цементной стяжки до 5 см."

Запрос "покраска стен" → не находит "Покраска стен водоэмульсионной краской"

Запрос "установка двери" → не находит "Установка межкомнатной двери"

3. Требования к функциональности
3.1. Основные требования:
Поиск должен работать по ВСЕМ словам из поискового запроса

Система должна обрабатывать любые комбинации слов из 3000+ позиций справочника

Поиск должен быть регистронезависимым

Пустой поисковый запрос должен возвращать все элементы справочника

3.2. Критерии поиска:
Разбивать поисковый запрос на отдельные слова по пробелам

Искать элементы, которые содержат ВСЕ слова из запроса (логическое И)

Учитывать порядок слов в запросе не требуется

Частичные совпадения слов должны работать ("демонтаж" найдет "Демонтаж", "демонтажа")

3.3. Обработка различных категорий позиций:
Система должна корректно работать для всех типов позиций в справочнике:

Строительные работы (демонтаж, монтаж, покраска, штукатурка)

Материалы (цемент, краска, двери, окна)

Услуги (установка, ремонт, обслуживание)

И другие категории из 3000+ позиций

4. Примеры поиска для различных категорий
Строительные работы:

"демонтаж стяжки" → "Демонтаж цементной стяжки", "Демонтаж стяжки пола"

"покраска стен" → "Покраска стен водоэмульсионной краской", "Покраска стен и потолков"

Монтажные работы:

"установка двери" → "Установка межкомнатной двери", "Установка входной двери"

"монтаж потолка" → "Монтаж натяжного потолка", "Монтаж гипсокартонного потолка"

Отделочные работы:

"штукатурка стен" → "Штукатурка стен цементным раствором", "Штукатурка кирпичных стен"

"укладка плитки" → "Укладка керамической плитки", "Укладка плитки на пол"

5. Тестовые сценарии для различных категорий
Дано: справочник из 3000+ позиций различных категорий

Ожидаемые результаты:

Запрос "демонтаж стяжки" → находит все позиции с обоими словами

Запрос "покраска стен краской" → находит позиции с тремя словами

Запрос "установка монтаж" → находит позиции, содержащие оба слова

Запрос "несуществующая комбинация" → возвращает пустой результат

Запрос "ремонт" → возвращает все позиции со словом "ремонт"

6. Требования к производительности
Поиск должен работать быстро для 3000+ элементов

Не должно быть заметных задержек при вводе текста

Оптимизировать алгоритм для большого количества данных

7. Критерии приемки
Поиск по одному слову работает как раньше для всех 3000+ позиций

Поиск по нескольким словам находит элементы, содержащие все слова запроса

Система работает для всех категорий позиций (строительство, монтаж, отделка и др.)

Регистр букв не влияет на результаты поиска

Пустой запрос возвращает все 3000+ элементов

Производительность поиска приемлемая для 3000+ позиций

Отображается сообщение при отсутствии результатов

Рекомендации по реализации поиска для 3000+ позиций
1. Подходы к реализации
Нативный подход (без библиотек)
Плюсы:

Нет зависимостей

Полный контроль

Меньше bundle size

Минусы:

Нужно самостоятельно оптимизировать

Ограниченный функционал

javascript
// Базовая реализация
const search = (items, query) => {
  const words = query.toLowerCase().split(' ').filter(w => w.length > 0);
  return items.filter(item => 
    words.every(word => item.name.toLowerCase().includes(word))
  );
};
2. Рекомендуемые библиотеки
Fuse.js - лучший выбор для вашего случая
bash
npm install fuse.js
Почему Fuse.js:

Идеально для 3000+ элементов

Поддерживает нечеткий поиск

Высокая производительность

Гибкая настройка

javascript
import Fuse from 'fuse.js';

const fuse = new Fuse(items, {
  keys: ['name'],
  threshold: 0.3, // уровень нечеткости
  minMatchCharLength: 2,
  shouldSort: true
});

const results = fuse.search('демонтаж стяжки');
Альтернативы:
Lunr.js - для более сложных сценариев

match-sorter - простой и быстрый

flexsearch - для очень больших данных

3. Оптимизации для нативного подхода
3.1. Предварительная обработка данных
javascript
// Создаем поисковый индекс
const createSearchIndex = (items) => {
  return items.map(item => ({
    ...item,
    searchText: item.name.toLowerCase()
  }));
};
3.2. Мемоизация и кеширование
javascript
import { useMemo } from 'react';

const useSearch = (items, query) => {
  return useMemo(() => {
    if (!query) return items;
    // логика поиска
  }, [items, query]);
};
3.3. Debounce для инпутов
javascript
import { useDebounce } from 'use-debounce';

const [query, setQuery] = useState('');
const [debouncedQuery] = useDebounce(query, 300);
4. Рекомендации по архитектуре
4.1. Для нативного решения:
javascript
const advancedSearch = (items, query) => {
  const words = query.toLowerCase()
    .split(' ')
    .filter(word => word.length > 2)
    .map(word => word.replace(/[^\wа-яё]/g, ''));
  
  return items.filter(item => {
    const text = item.name.toLowerCase();
    return words.every(word => text.includes(word));
  });
};
4.2. Для Fuse.js:
javascript
const fuseOptions = {
  keys: ['name', 'category'], // по каким полям искать
  includeScore: true,
  threshold: 0.4,
  minMatchCharLength: 2,
  ignoreLocation: true, // искать по всему тексту
  findAllMatches: true
};
5. Производительность
Метрики для 3000 элементов:
Нативный поиск: ~5-50ms

Fuse.js: ~10-100ms (с нечетким поиском)

Приемлемое время: до 100ms

Оптимизации:
Virtual scroll для отображения результатов

Web Worker для тяжелых вычислений

Разбивка на страницы (пагинация)